import logging
import os
import sys
from datasets import load_metric, load_from_disk, load_dataset, concatenate_datasets
import re

from transformers import AutoConfig, AutoModelForQuestionAnswering, AutoTokenizer, EarlyStoppingCallback, T5ForConditionalGeneration, T5Tokenizer, T5Config, DataCollatorForSeq2Seq, Seq2SeqTrainer, Seq2SeqTrainingArguments
from transformers import (
    DataCollatorWithPadding,
    EvalPrediction,
    HfArgumentParser,
    TrainingArguments,
    set_seed,
)
import pandas as pd
from utils_qa import postprocess_qa_predictions, check_no_error, tokenize
from trainer_qa import QuestionAnsweringTrainer
from retrieval import SparseRetrieval

from arguments import (
    ModelArguments,
    DataTrainingArguments,
)

# -*- coding: utf-8 -*-
"""MRC Mission 2 - Generation-based MRC.ipynb의 사본

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hkgn1YvQPv9SSn3PI9hOMDXnLfDsPJeP

# Generation-based MRC 문제를 풀어보기
"""
import nltk

"""## 데이터 및 평가 지표 불러오기"""

# datasets = load_dataset("squad_kor_v1")
datasets = load_from_disk('/opt/ml/input/data/data/train_dataset')
metric = load_metric('squad')

"""## Pre-trained 모델 및 토크나이저 불러오기"""

model_name = "KETI-AIR/ke-t5-base-ko"

config = T5Config.from_pretrained(
    model_name,
    cache_dir=None,
)
tokenizer = T5Tokenizer.from_pretrained(
    model_name,
    cache_dir=None,
    use_fast=True,
)
model = T5ForConditionalGeneration.from_pretrained(
    model_name,
    config=config,
    cache_dir=None,
)

"""## 설정하기"""

max_source_length = 1024
max_target_length = 128
padding = False
preprocessing_num_workers=12
num_beams = 2
max_train_samples = 16
max_val_samples = 16
batch_size = 8
num_train_epochs = 2


"""## 전처리하기"""

def preprocess_function(examples):
    inputs = [f'question: {q} context: {c}' for q, c in zip(examples['question'], examples['context'])]
    targets = [f'{a["text"][0]}' for a in examples['answers']]
    model_inputs = tokenizer(inputs, max_length=max_source_length, padding=padding, truncation=True)

    # Setup the tokenizer for targets
    with tokenizer.as_target_tokenizer():
        labels = tokenizer(targets, max_length=max_target_length, padding=padding, truncation=True)

    model_inputs["labels"] = labels["input_ids"]
    model_inputs["example_id"] = []
    for i in range(len(model_inputs["labels"])):
        model_inputs["example_id"].append(examples["id"][i])
    return model_inputs
column_names = datasets['train'].column_names

# TODO: Train mt5 on whole KorQuAD datset

train_dataset = datasets["train"]
# train_dataset = train_dataset.select(range(max_train_samples))
train_dataset = train_dataset.map(
            preprocess_function,
            batched=True,
            num_proc=preprocessing_num_workers,
            remove_columns=column_names,
            load_from_cache_file=False,
        )

# TODO: Train mt5 on whole KorQuAD datseteval_dataset = datasets["validation"]

eval_dataset = datasets["validation"]
# eval_dataset = eval_dataset.select(range(max_val_samples))
eval_dataset = eval_dataset.map(
            preprocess_function,
            batched=True,
            num_proc=preprocessing_num_workers,
            remove_columns=column_names,
            load_from_cache_file=False,
        )

"""## Fine-tuning하기"""

label_pad_token_id = tokenizer.pad_token_id
data_collator = DataCollatorForSeq2Seq(
            tokenizer,
            model=model,
            label_pad_token_id=label_pad_token_id,
            pad_to_multiple_of=None,
        )

def postprocess_text(preds, labels):
    preds = [pred.strip() for pred in preds]
    labels = [label.strip() for label in labels]
    
    preds = ["\n".join(nltk.sent_tokenize(pred)) for pred in preds]
    labels = ["\n".join(nltk.sent_tokenize(label)) for label in labels]

    return preds, labels

def compute_metrics(eval_preds):
    preds, labels = eval_preds
    if isinstance(preds, tuple):
        preds = preds[0]
    
    decoded_preds = tokenizer.batch_decode(preds, skip_special_tokens=True)
    # decoded_labels is for rouge metric, not used for f1/em metric
    decoded_labels = tokenizer.batch_decode(labels, skip_special_tokens=True)

    # Some simple post-processing
    decoded_preds, decoded_labels = postprocess_text(decoded_preds, decoded_labels)

    formatted_predictions = [{"id": ex['id'], "prediction_text": decoded_preds[i]} for i, ex in enumerate(datasets["validation"].select(range(max_val_samples)))]
    references = [{"id": ex["id"], "answers": ex["answers"]} for ex in datasets["validation"].select(range(max_val_samples))]

    result = metric.compute(predictions=formatted_predictions, references=references)
    return result

args = Seq2SeqTrainingArguments(
    output_dir='./outputs', 
    do_train=True, 
    do_eval=True, 
    predict_with_generate=True,
    per_device_train_batch_size=batch_size,
    per_device_eval_batch_size=batch_size,
    num_train_epochs=num_train_epochs,
    save_strategy='epoch',
    save_total_limit=1,
    learning_rate=1e-5
)

trainer = Seq2SeqTrainer(
    model=model,
    args=args,
    train_dataset=train_dataset,
    eval_dataset=eval_dataset,
    tokenizer=tokenizer,
    data_collator=data_collator,
    compute_metrics=compute_metrics,
)

train_result = trainer.train(resume_from_checkpoint=None)

print(train_result)

"""## 평가하기"""

metrics = trainer.evaluate(
    max_length=max_target_length, num_beams=num_beams, metric_key_prefix="eval"
)

print(metrics)

document = "세종대왕은 언제 태어났어?"
input_ids = tokenizer(document, return_tensors='pt').input_ids
outputs = model.generate(input_ids.to('cuda'))
print(tokenizer.decode(outputs[0], skip_special_tokens=True))




# logger = logging.getLogger(__name__)

# def remove_newlines(example) :
#     new_ones = [] 
#     for i, context in enumerate(example) :
#         new_one = re.sub(r'\\n', '', context)
#         new_ones.append(new_one)

#     return new_ones

# def remove_double_space(example) :
#     new_ones = []
#     for i, context in enumerate(example) :
#         new_one = re.sub('  ', ' ', context)
#         new_ones.append(new_one)

#     return new_ones

# def main():
#     # 가능한 arguments 들은 ./arguments.py 나 transformer package 안의 src/transformers/training_args.py 에서 확인 가능합니다.
#     # --help flag 를 실행시켜서 확인할 수 도 있습니다.

#     parser = HfArgumentParser(
#         (ModelArguments, DataTrainingArguments, TrainingArguments)
#     )
#     model_args, data_args, training_args = parser.parse_args_into_dataclasses()
    
#     model_args.model_name_or_path = 'KETI-AIR/ke-t5-large'

#     print(f"model is from {model_args.model_name_or_path}")
#     print(f"data is from {data_args.dataset_name}")

#     # Setup logging
#     logging.basicConfig(
#         format="%(asctime)s - %(levelname)s - %(name)s -   %(message)s",
#         datefmt="%m/%d/%Y %H:%M:%S",
#         handlers=[logging.StreamHandler(sys.stdout)],
#     )

#     # Set the verbosity to info of the Transformers logger (on main process only):
#     logger.info("Training/evaluation parameters %s", training_args)

#     # Set seed before initializing model.
#     set_seed(training_args.seed)

#     # KLUE MRC DATASET
#     # datasets = load_from_disk(data_args.dataset_name)

#     # KORQUAD DATASET
#     datasets = load_dataset('squad_kor_v1')

#     # KLUE + KORQUAD DATASET
#     # datasets = load_dataset("squad_kor_v1")
#     # dataset_KLUE = load_from_disk('/opt/ml/input/data/data/train_dataset')
#     # dataset_KLUE_train = dataset_KLUE['train'].map(features=datasets['train'].features, 
#     #                                                     remove_columns=['document_id', '__index_level_0__'], 
#     #                                                     keep_in_memory=True)
#     # dataset_KLUE_validation = dataset_KLUE['validation'].map(features=datasets['validation'].features, 
#     #                                                     remove_columns=['document_id', '__index_level_0__'], 
#     #                                                     keep_in_memory=True)
#     # datasets['train'] = concatenate_datasets([dataset_KLUE_train, datasets['train']])
#     # datasets['validation'] = concatenate_datasets([dataset_KLUE_validation, datasets['validation']])

#     print(datasets)

#     # Load pretrained model and tokenizer
#     config = T5Config.from_pretrained(
#         model_args.config_name
#         if model_args.config_name
#         else model_args.model_name_or_path,
#     )
#     tokenizer = T5Tokenizer.from_pretrained(
#         model_args.tokenizer_name
#         if model_args.tokenizer_name
#         else model_args.model_name_or_path,
#         use_fast=True,
#     )
#     model = T5ForConditionalGeneration.from_pretrained(
#         model_args.model_name_or_path,
#         from_tf=bool(".ckpt" in model_args.model_name_or_path),
#         config=config,
#     )

#     # train & save sparse embedding retriever if true
#     if data_args.train_retrieval:
#         run_sparse_embedding()

#     # train or eval mrc model
#     if training_args.do_train or training_args.do_eval:
#         run_mrc(data_args, training_args, model_args, datasets, tokenizer, model)


# def run_sparse_embedding():
#     retriever = SparseRetrieval(tokenize_fn=tokenize,
#                                 data_path="/opt/ml/input/data/data",
#                                 context_path="wikipedia_documents.json")
#     retriever.get_sparse_embedding()


# def run_mrc(data_args, training_args, model_args, datasets, tokenizer, model):
#     # Preprocessing the datasets.
#     # Preprocessing is slighlty different for training and evaluation.
#     if training_args.do_train:
#         column_names = datasets["train"].column_names
#     else:
#         column_names = datasets["validation"].column_names

#     question_column_name = "question" if "question" in column_names else column_names[0]
#     context_column_name = "context" if "context" in column_names else column_names[1]
#     answer_column_name = "answers" if "answers" in column_names else column_names[2]

#     # Padding side determines if we do (question|context) or (context|question).
#     pad_on_right = tokenizer.padding_side == "right"

#     # check if there is an error
#     last_checkpoint, max_seq_length = check_no_error(training_args, data_args, tokenizer, datasets)

#     # Training preprocessing
#     def prepare_train_features(examples):
#         # Tokenize our examples with truncation and maybe padding, but keep the overflows using a stride. This results
#         # in one example possible giving several features when a context is long, each of those features having a
#         # context that overlaps a bit the context of the previous feature.

#         '''
#             여기에 전처리 넣어야되나?
#         '''
#         tokenized_examples = tokenizer(
#             examples[question_column_name if pad_on_right else context_column_name],
#             examples[context_column_name if pad_on_right else question_column_name], # 기존
#             # remove_double_space(remove_newlines(examples[context_column_name if pad_on_right else question_column_name])),  # 전처리 추가
#             truncation="only_second" if pad_on_right else "only_first",
#             max_length=max_seq_length,
#             stride=data_args.doc_stride,
#             return_overflowing_tokens=True,
#             return_offsets_mapping=True,
#             padding="max_length" if data_args.pad_to_max_length else False,
#         )

#         # Since one example might give us several features if it has a long context, we need a map from a feature to
#         # its corresponding example. This key gives us just that.
#         sample_mapping = tokenized_examples.pop("overflow_to_sample_mapping")
#         # The offset mappings will give us a map from token to character position in the original context. This will
#         # help us compute the start_positions and end_positions.
#         offset_mapping = tokenized_examples.pop("offset_mapping")

#         # Let's label those examples!
#         tokenized_examples["start_positions"] = []
#         tokenized_examples["end_positions"] = []

#         for i, offsets in enumerate(offset_mapping):
#             # We will label impossible answers with the index of the CLS token.
#             input_ids = tokenized_examples["input_ids"][i]
#             cls_index = input_ids.index(tokenizer.cls_token_id)

#             # Grab the sequence corresponding to that example (to know what is the context and what is the question).
#             sequence_ids = tokenized_examples.sequence_ids(i)

#             # One example can give several spans, this is the index of the example containing this span of text.
#             sample_index = sample_mapping[i]
#             answers = examples[answer_column_name][sample_index]
#             # print(answers)
#             # If no answers are given, set the cls_index as answer.
#             if len(answers["answer_start"]) == 0:
#                 tokenized_examples["start_positions"].append(cls_index)
#                 tokenized_examples["end_positions"].append(cls_index)
#             else:
#                 # Start/end character index of the answer in the text.
#                 start_char = answers["answer_start"][0]
#                 end_char = start_char + len(answers["text"][0])

#                 # Start token index of the current span in the text.
#                 token_start_index = 0
#                 while sequence_ids[token_start_index] != (1 if pad_on_right else 0):
#                     token_start_index += 1

#                 # End token index of the current span in the text.
#                 token_end_index = len(input_ids) - 1
#                 while sequence_ids[token_end_index] != (1 if pad_on_right else 0):
#                     token_end_index -= 1

#                 # Detect if the answer is out of the span (in which case this feature is labeled with the CLS index).
#                 if not (
#                     offsets[token_start_index][0] <= start_char
#                     and offsets[token_end_index][1] >= end_char
#                 ):
#                     tokenized_examples["start_positions"].append(cls_index)
#                     tokenized_examples["end_positions"].append(cls_index)
#                 else:
#                     # Otherwise move the token_start_index and token_end_index to the two ends of the answer.
#                     # Note: we could go after the last offset if the answer is the last word (edge case).
#                     while (
#                         token_start_index < len(offsets)
#                         and offsets[token_start_index][0] <= start_char
#                     ):
#                         token_start_index += 1
#                     tokenized_examples["start_positions"].append(token_start_index - 1)
#                     while offsets[token_end_index][1] >= end_char:
#                         token_end_index -= 1
#                     tokenized_examples["end_positions"].append(token_end_index + 1)

#         return tokenized_examples

#     if training_args.do_train:
#         if "train" not in datasets:
#             raise ValueError("--do_train requires a train dataset")
#         train_dataset = datasets["train"]

#         # Create train feature from dataset
#         train_dataset = train_dataset.map(
#             prepare_train_features,
#             batched=True,
#             num_proc=data_args.preprocessing_num_workers,
#             remove_columns=column_names,
#             load_from_cache_file=not data_args.overwrite_cache,
#         )

#     # Validation preprocessing
#     def prepare_validation_features(examples):
#         # Tokenize our examples with truncation and maybe padding, but keep the overflows using a stride. This results
#         # in one example possible giving several features when a context is long, each of those features having a
#         # context that overlaps a bit the context of the previous feature.
#         '''
#             여기도 전처리
#         '''
#         tokenized_examples = tokenizer(
#             examples[question_column_name if pad_on_right else context_column_name],
#             examples[context_column_name if pad_on_right else question_column_name],   # 기존
#             # remove_double_space(remove_newlines(examples[context_column_name if pad_on_right else question_column_name])),  #  전처리 추가
#             truncation="only_second" if pad_on_right else "only_first",
#             max_length=max_seq_length,
#             stride=data_args.doc_stride,
#             return_overflowing_tokens=True,
#             return_offsets_mapping=True,
#             padding="max_length" if data_args.pad_to_max_length else False,
#         )

#         # Since one example might give us several features if it has a long context, we need a map from a feature to
#         # its corresponding example. This key gives us just that.
#         sample_mapping = tokenized_examples.pop("overflow_to_sample_mapping")

#         # For evaluation, we will need to convert our predictions to substrings of the context, so we keep the
#         # corresponding example_id and we will store the offset mappings.
#         tokenized_examples["example_id"] = []

#         for i in range(len(tokenized_examples["input_ids"])):
#             # Grab the sequence corresponding to that example (to know what is the context and what is the question).
#             sequence_ids = tokenized_examples.sequence_ids(i)
#             context_index = 1 if pad_on_right else 0

#             # One example can give several spans, this is the index of the example containing this span of text.
#             sample_index = sample_mapping[i]
#             tokenized_examples["example_id"].append(examples["id"][sample_index])

#             # Set to None the offset_mapping that are not part of the context so it's easy to determine if a token
#             # position is part of the context or not.
#             tokenized_examples["offset_mapping"][i] = [
#                 (o if sequence_ids[k] == context_index else None)
#                 for k, o in enumerate(tokenized_examples["offset_mapping"][i])
#             ]
#         return tokenized_examples

#     if training_args.do_eval:
#         eval_dataset = datasets["validation"]

#         # Validation Feature Creation
#         eval_dataset = eval_dataset.map(
#             prepare_validation_features,
#             batched=True,
#             num_proc=data_args.preprocessing_num_workers,
#             remove_columns=column_names,
#             load_from_cache_file=not data_args.overwrite_cache,
#         )

#     # Data collator
#     # We have already padded to max length if the corresponding flag is True, otherwise we need to pad in the data collator.
#     data_collator = (
#         DataCollatorWithPadding(
#             tokenizer, pad_to_multiple_of=8 if training_args.fp16 else None
#         )
#     )

#     # Post-processing:
#     def post_processing_function(examples, features, predictions, training_args):
#         # Post-processing: we match the start logits and end logits to answers in the original context.
#         predictions = postprocess_qa_predictions(
#             examples=examples,
#             features=features,
#             predictions=predictions,
#             max_answer_length=data_args.max_answer_length,
#             output_dir=training_args.output_dir,
#         )
#         # Format the result to the format the metric expects.
#         formatted_predictions = [
#             {"id": k, "prediction_text": v} for k, v in predictions.items()
#         ]

#         if training_args.do_predict:
#             return formatted_predictions

#         elif training_args.do_eval:
#             references = [
#                 {"id": ex["id"], "answers": ex[answer_column_name]}
#                 for ex in datasets["validation"]
#             ]


#             return EvalPrediction(predictions=formatted_predictions, label_ids=references)

#     metric = load_metric("squad")

#     def compute_metrics(p: EvalPrediction):
#         return metric.compute(predictions=p.predictions, references=p.label_ids)

#     early_stopping = EarlyStoppingCallback(early_stopping_patience=3, early_stopping_threshold=0.001)

#     # Initialize our Trainer
#     trainer = QuestionAnsweringTrainer(
#         model=model,
#         args=training_args,
#         train_dataset=train_dataset if training_args.do_train else None,
#         eval_dataset=eval_dataset if training_args.do_eval else None,
#         eval_examples=datasets["validation"] if training_args.do_eval else None,
#         tokenizer=tokenizer,
#         data_collator=data_collator,
#         post_process_function=post_processing_function,
#         compute_metrics=compute_metrics,
#         callbacks=[early_stopping]
#     )

#     # Training
#     if training_args.do_train:
#         if last_checkpoint is not None:
#             checkpoint = last_checkpoint
#         elif os.path.isdir(model_args.model_name_or_path):
#             checkpoint = model_args.model_name_or_path
#         else:
#             checkpoint = None
#         train_result = trainer.train(resume_from_checkpoint=checkpoint)
#         trainer.save_model()  # Saves the tokenizer too for easy upload

#         metrics = train_result.metrics
#         metrics["train_samples"] = len(train_dataset)

#         trainer.log_metrics("train", metrics)
#         trainer.save_metrics("train", metrics)
#         trainer.save_state()

#         output_train_file = os.path.join(training_args.output_dir, "train_results.txt")

#         with open(output_train_file, "w") as writer:
#             logger.info("***** Train results *****")
#             for key, value in sorted(train_result.metrics.items()):
#                 logger.info(f"  {key} = {value}")
#                 writer.write(f"{key} = {value}\n")

#         # Need to save the state, since Trainer.save_model saves only the tokenizer with the model
#         trainer.state.save_to_json(
#             os.path.join(training_args.output_dir, "trainer_state.json")
#         )

#     # Evaluation
#     if training_args.do_eval:
#         logger.info("*** Evaluate ***")
#         metrics = trainer.evaluate()

#         metrics["eval_samples"] = len(eval_dataset)

#         trainer.log_metrics("eval", metrics)
#         trainer.save_metrics("eval", metrics)


# if __name__ == "__main__":
#     main()
